"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/version.ts
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "2.6.1";
var PKG_FORMAT = "cjs";

// src/ClientSideSuspense.tsx
var _react = require('react'); var React = _interopRequireWildcard(_react); var React4 = _interopRequireWildcard(_react); var React3 = _interopRequireWildcard(_react);
function ClientSideSuspense(props) {
  const [mounted, setMounted] = React.useState(false);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: props.fallback }, mounted ? typeof props.children === "function" ? props.children() : props.children : props.fallback);
}

// src/comments/lib/selected-threads.ts


var _core = require('@liveblocks/core');
function selectedUserThreads(state) {
  const result = _core.applyOptimisticUpdates.call(void 0, state);
  const threads = Object.values(result.threads).filter(
    (thread) => {
      if (thread.deletedAt !== void 0) {
        return false;
      }
      return true;
    }
  );
  return threads.sort(
    (a, b) => (_nullishCoalesce(b.updatedAt, () => ( b.createdAt))).getTime() - (_nullishCoalesce(a.updatedAt, () => ( a.createdAt))).getTime()
  );
}
function selectedThreads(roomId, state, options) {
  const result = _core.applyOptimisticUpdates.call(void 0, state);
  const threads = Object.values(result.threads).filter(
    (thread) => {
      if (thread.roomId !== roomId) return false;
      if (thread.deletedAt !== void 0) {
        return false;
      }
      const query = options.query;
      if (!query) return true;
      if (query.resolved !== void 0 && thread.resolved !== query.resolved) {
        return false;
      }
      for (const key in query.metadata) {
        const metadataValue = thread.metadata[key];
        const filterValue = query.metadata[key];
        if (assertFilterIsStartsWithOperator(filterValue) && assertMetadataValueIsString(metadataValue)) {
          if (metadataValue.startsWith(filterValue.startsWith)) {
            return true;
          }
        }
        if (metadataValue !== filterValue) {
          return false;
        }
      }
      return true;
    }
  );
  return threads.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
}
var assertFilterIsStartsWithOperator = (filter) => {
  if (typeof filter === "object" && typeof filter.startsWith === "string") {
    return true;
  } else {
    return false;
  }
};
var assertMetadataValueIsString = (value) => {
  return typeof value === "string";
};

// src/comments/errors.ts
var CreateThreadError = class extends Error {
  constructor(cause, context) {
    super("Create thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateThreadError";
  }
};
var DeleteThreadError = class extends Error {
  constructor(cause, context) {
    super("Delete thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteThreadError";
  }
};
var EditThreadMetadataError = class extends Error {
  constructor(cause, context) {
    super("Edit thread metadata failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditThreadMetadataError";
  }
};
var MarkThreadAsResolvedError = class extends Error {
  constructor(cause, context) {
    super("Mark thread as resolved failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkThreadAsResolvedError";
  }
};
var MarkThreadAsUnresolvedError = class extends Error {
  constructor(cause, context) {
    super("Mark thread as unresolved failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkThreadAsUnresolvedError";
  }
};
var CreateCommentError = class extends Error {
  constructor(cause, context) {
    super("Create comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateCommentError";
  }
};
var EditCommentError = class extends Error {
  constructor(cause, context) {
    super("Edit comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditCommentError";
  }
};
var DeleteCommentError = class extends Error {
  constructor(cause, context) {
    super("Delete comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteCommentError";
  }
};
var AddReactionError = class extends Error {
  constructor(cause, context) {
    super("Add reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "AddReactionError";
  }
};
var RemoveReactionError = class extends Error {
  constructor(cause, context) {
    super("Remove reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "RemoveReactionError";
  }
};
var MarkInboxNotificationAsReadError = class extends Error {
  constructor(cause, context) {
    super("Mark inbox notification as read failed.");
    this.cause = cause;
    this.context = context;
    this.name = "MarkInboxNotificationAsReadError";
  }
};
var UpdateNotificationSettingsError = class extends Error {
  constructor(cause, context) {
    super("Update notification settings failed.");
    this.cause = cause;
    this.context = context;
    this.name = "UpdateNotificationSettingsError";
  }
};

// src/room.tsx
var _client = require('@liveblocks/client');




















var _withselectorjs = require('use-sync-external-store/shim/with-selector.js');

// src/comments/lib/select-notification-settings.ts




function selectNotificationSettings(roomId, state) {
  const { notificationSettings } = _core.applyOptimisticUpdates.call(void 0, state);
  return _core.nn.call(void 0, notificationSettings[roomId]);
}

// src/comments/lib/selected-inbox-notifications.ts

function selectedInboxNotifications(state) {
  const result = _core.applyOptimisticUpdates.call(void 0, state);
  return Object.values(result.inboxNotifications).sort(
    // Sort so that the most recent notifications are first
    (a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime()
  );
}

// src/lib/retry-error.ts

var MAX_ERROR_RETRY_COUNT = 5;
var ERROR_RETRY_INTERVAL = 5e3;
function retryError(action, retryCount) {
  if (retryCount >= MAX_ERROR_RETRY_COUNT) return;
  const timeout = Math.pow(2, retryCount) * ERROR_RETRY_INTERVAL;
  setTimeout(() => {
    void action();
  }, timeout);
}
async function autoRetry(promiseFn, maxTries, backoff) {
  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;
  let attempt = 0;
  while (true) {
    attempt++;
    const promise = promiseFn();
    try {
      return await promise;
    } catch (err) {
      if (attempt >= maxTries) {
        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);
      }
    }
    const delay = _nullishCoalesce(backoff[attempt - 1], () => ( fallbackBackoff));
    await _core.wait.call(void 0, delay);
  }
}

// src/lib/use-initial.ts


// src/lib/use-latest.ts

function useLatest(value) {
  const ref = _react.useRef.call(void 0, value);
  _react.useEffect.call(void 0, () => {
    ref.current = value;
  }, [value]);
  return ref;
}

// src/lib/use-initial.ts
var noop = (state) => state;
function useInitial(value) {
  return _react.useReducer.call(void 0, noop, value)[0];
}
function useInitialUnlessFunction(latestValue) {
  const frozenValue = useInitial(latestValue);
  if (typeof frozenValue === "function") {
    const ref = useLatest(latestValue);
    return _react.useCallback.call(void 0, (...args) => ref.current(...args), [
      ref
    ]);
  } else {
    return frozenValue;
  }
}

// src/lib/use-polyfill.ts
var use = (
  // React.use ||
  (promise) => {
    if (promise.status === "pending") {
      throw promise;
    } else if (promise.status === "fulfilled") {
      return promise.value;
    } else if (promise.status === "rejected") {
      throw promise.reason;
    } else {
      promise.status = "pending";
      promise.then(
        (v) => {
          promise.status = "fulfilled";
          promise.value = v;
        },
        (e) => {
          promise.status = "rejected";
          promise.reason = e;
        }
      );
      throw promise;
    }
  }
);

// src/liveblocks.tsx

















var _indexjs = require('use-sync-external-store/shim/index.js');

var ClientContext = _react.createContext.call(void 0, null);
function missingUserError(userId) {
  return new Error(`resolveUsers didn't return anything for user '${userId}'`);
}
function missingRoomInfoError(roomId) {
  return new Error(
    `resolveRoomsInfo didn't return anything for room '${roomId}'`
  );
}
var _extras = /* @__PURE__ */ new WeakMap();
var _bundles = /* @__PURE__ */ new WeakMap();
var POLLING_INTERVAL = 60 * 1e3;
var INBOX_NOTIFICATIONS_QUERY = "INBOX_NOTIFICATIONS";
var USER_THREADS_QUERY = "USER_THREADS";
function selectorFor_useInboxNotifications(state) {
  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];
  if (query === void 0 || query.isLoading) {
    return {
      isLoading: true
    };
  }
  if (query.error !== void 0) {
    return {
      error: query.error,
      isLoading: false
    };
  }
  return {
    inboxNotifications: selectedInboxNotifications(state),
    isLoading: false
  };
}
function selectorFor_useUserThreads(state) {
  const query = state.queries[USER_THREADS_QUERY];
  if (query === void 0 || query.isLoading) {
    return {
      isLoading: true
    };
  }
  if (query.error !== void 0) {
    return {
      threads: [],
      error: query.error,
      isLoading: false
    };
  }
  return {
    threads: selectedUserThreads(state),
    isLoading: false
  };
}
function selectUnreadInboxNotificationsCount(state) {
  let count = 0;
  for (const notification of selectedInboxNotifications(state)) {
    if (notification.readAt === null || notification.readAt < notification.notifiedAt) {
      count++;
    }
  }
  return count;
}
function selectorFor_useUnreadInboxNotificationsCount(state) {
  const query = state.queries[INBOX_NOTIFICATIONS_QUERY];
  if (query === void 0 || query.isLoading) {
    return {
      isLoading: true
    };
  }
  if (query.error !== void 0) {
    return {
      error: query.error,
      isLoading: false
    };
  }
  return {
    isLoading: false,
    count: selectUnreadInboxNotificationsCount(state)
  };
}
function selectorFor_useUser(state, userId) {
  if (state === void 0 || _optionalChain([state, 'optionalAccess', _2 => _2.isLoading])) {
    return _nullishCoalesce(state, () => ( { isLoading: true }));
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingUserError(userId)
    };
  }
  return {
    isLoading: false,
    user: state.data
  };
}
function selectorFor_useRoomInfo(state, roomId) {
  if (state === void 0 || _optionalChain([state, 'optionalAccess', _3 => _3.isLoading])) {
    return _nullishCoalesce(state, () => ( { isLoading: true }));
  }
  if (state.error) {
    return state;
  }
  if (!state.data) {
    return {
      isLoading: false,
      error: missingRoomInfoError(roomId)
    };
  }
  return {
    isLoading: false,
    info: state.data
  };
}
function getOrCreateContextBundle(client) {
  let bundle = _bundles.get(client);
  if (!bundle) {
    bundle = makeLiveblocksContextBundle(client);
    _bundles.set(client, bundle);
  }
  return bundle;
}
function getExtrasForClient(client) {
  let extras = _extras.get(client);
  if (!extras) {
    extras = makeExtrasForClient(client);
    _extras.set(client, extras);
  }
  return extras;
}
function makeExtrasForClient(client) {
  const internals = client[_core.kInternal];
  const store = internals.cacheStore;
  let lastRequestedAt;
  async function fetchInboxNotifications() {
    if (lastRequestedAt === void 0) {
      const result = await client.getInboxNotifications();
      store.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications,
        [],
        [],
        INBOX_NOTIFICATIONS_QUERY
      );
      lastRequestedAt = result.requestedAt;
    } else {
      const result = await client.getInboxNotificationsSince({
        since: lastRequestedAt
      });
      store.updateThreadsAndNotifications(
        result.threads.updated,
        result.inboxNotifications.updated,
        result.threads.deleted,
        result.inboxNotifications.deleted,
        INBOX_NOTIFICATIONS_QUERY
      );
      if (lastRequestedAt < result.requestedAt) {
        lastRequestedAt = result.requestedAt;
      }
    }
  }
  let pollerSubscribers = 0;
  const poller = _core.makePoller.call(void 0, async () => {
    try {
      await waitUntilInboxNotificationsLoaded();
      await fetchInboxNotifications();
    } catch (err) {
      console.warn(`Polling new inbox notifications failed: ${String(err)}`);
    }
  });
  const waitUntilInboxNotificationsLoaded = _core.memoizeOnSuccess.call(void 0, async () => {
    store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {
      isLoading: true
    });
    try {
      await autoRetry(
        () => fetchInboxNotifications(),
        5,
        [5e3, 5e3, 1e4, 15e3]
      );
    } catch (err) {
      store.setQueryState(INBOX_NOTIFICATIONS_QUERY, {
        isLoading: false,
        error: err
      });
      throw err;
    }
  });
  function loadInboxNotifications() {
    void waitUntilInboxNotificationsLoaded().catch(() => {
    });
  }
  function useEnableInboxNotificationsPolling() {
    _react.useEffect.call(void 0, () => {
      pollerSubscribers++;
      poller.start(POLLING_INTERVAL);
      return () => {
        if (pollerSubscribers <= 0) {
          console.warn(
            `Internal unexpected behavior. Cannot decrease subscriber count for query "${INBOX_NOTIFICATIONS_QUERY}"`
          );
          return;
        }
        pollerSubscribers--;
        if (pollerSubscribers <= 0) {
          poller.stop();
        }
      };
    }, []);
  }
  let userThreadsPollerSubscribers = 0;
  const userThreadsPoller = _core.makePoller.call(void 0, async () => {
    try {
      await waitUntilUserThreadsLoaded();
      await fetchUserThreads();
    } catch (err) {
      console.warn(`Polling new user threads failed: ${String(err)}`);
    }
  });
  let userThreadslastRequestedAt;
  function loadUserThreads() {
    void waitUntilUserThreadsLoaded().catch(() => {
    });
  }
  const waitUntilUserThreadsLoaded = _core.memoizeOnSuccess.call(void 0, async () => {
    store.setQueryState(USER_THREADS_QUERY, {
      isLoading: true
    });
    try {
      await autoRetry(() => fetchUserThreads(), 5, [5e3, 5e3, 1e4, 15e3]);
    } catch (err) {
      store.setQueryState(USER_THREADS_QUERY, {
        isLoading: false,
        error: err
      });
      throw err;
    }
  });
  async function fetchUserThreads() {
    if (userThreadslastRequestedAt === void 0) {
      const result = await client[_core.kInternal].getThreads();
      store.updateThreadsAndNotifications(
        result.threads,
        result.inboxNotifications,
        [],
        [],
        USER_THREADS_QUERY
      );
      userThreadslastRequestedAt = result.requestedAt;
    } else {
      const result = await client[_core.kInternal].getThreadsSince({
        since: userThreadslastRequestedAt
      });
      store.updateThreadsAndNotifications(
        result.threads.updated,
        result.inboxNotifications.updated,
        result.threads.deleted,
        result.inboxNotifications.deleted,
        USER_THREADS_QUERY
      );
      if (userThreadslastRequestedAt < result.requestedAt) {
        userThreadslastRequestedAt = result.requestedAt;
      }
    }
  }
  function useEnableUserThreadsPolling() {
    _react.useEffect.call(void 0, () => {
      userThreadsPollerSubscribers++;
      userThreadsPoller.start(POLLING_INTERVAL);
      return () => {
        if (userThreadsPollerSubscribers <= 0) {
          console.warn(
            `Internal unexpected behavior. Cannot decrease subscriber count for query "${USER_THREADS_QUERY}"`
          );
          return;
        }
        userThreadsPollerSubscribers--;
        if (userThreadsPollerSubscribers <= 0) {
          userThreadsPoller.stop();
        }
      };
    }, []);
  }
  return {
    store,
    useEnableInboxNotificationsPolling,
    waitUntilInboxNotificationsLoaded,
    loadInboxNotifications,
    useEnableUserThreadsPolling,
    waitUntilUserThreadsLoaded,
    loadUserThreads
  };
}
function makeLiveblocksContextBundle(client) {
  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);
  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);
  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);
  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);
  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);
  function LiveblocksProvider2(props) {
    useEnsureNoLiveblocksProvider();
    return /* @__PURE__ */ React.default.createElement(ClientContext.Provider, { value: client }, props.children);
  }
  const shared = createSharedContext(client);
  const bundle = {
    LiveblocksProvider: LiveblocksProvider2,
    useInboxNotifications: () => useInboxNotifications_withClient(client),
    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),
    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
    useDeleteInboxNotification: useDeleteInboxNotification2,
    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
    useInboxNotificationThread: useInboxNotificationThread2,
    useUserThreads_experimental: () => useUserThreads_withClient(client),
    ...shared.classic,
    suspense: {
      LiveblocksProvider: LiveblocksProvider2,
      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),
      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),
      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,
      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,
      useDeleteInboxNotification: useDeleteInboxNotification2,
      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,
      useInboxNotificationThread: useInboxNotificationThread2,
      useUserThreads_experimental: () => useUserThreadsSuspense_withClient(client),
      ...shared.suspense
    }
  };
  return bundle;
}
function useUserThreads_withClient(client) {
  const { loadUserThreads, store, useEnableUserThreadsPolling } = getExtrasForClient(client);
  _react.useEffect.call(void 0, () => {
    loadUserThreads();
  }, [loadUserThreads]);
  useEnableUserThreadsPolling();
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selectorFor_useUserThreads,
    _core.shallow
  );
}
function useUserThreadsSuspense_withClient(client) {
  const { waitUntilUserThreadsLoaded } = getExtrasForClient(client);
  use(waitUntilUserThreadsLoaded());
  const result = useUserThreads_withClient(client);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useInboxNotifications_withClient(client) {
  const { loadInboxNotifications, store, useEnableInboxNotificationsPolling } = getExtrasForClient(client);
  _react.useEffect.call(void 0, () => {
    loadInboxNotifications();
  }, [loadInboxNotifications]);
  useEnableInboxNotificationsPolling();
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selectorFor_useInboxNotifications,
    _core.shallow
  );
}
function useInboxNotificationsSuspense_withClient(client) {
  const { waitUntilInboxNotificationsLoaded } = getExtrasForClient(client);
  use(waitUntilInboxNotificationsLoaded());
  const result = useInboxNotifications_withClient(client);
  _core.assert.call(void 0, !result.error, "Did not expect error");
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  return result;
}
function useUnreadInboxNotificationsCount_withClient(client) {
  const { store, loadInboxNotifications, useEnableInboxNotificationsPolling } = getExtrasForClient(client);
  _react.useEffect.call(void 0, () => {
    loadInboxNotifications();
  }, [loadInboxNotifications]);
  useEnableInboxNotificationsPolling();
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selectorFor_useUnreadInboxNotificationsCount,
    _core.shallow
  );
}
function useUnreadInboxNotificationsCountSuspense_withClient(client) {
  const { waitUntilInboxNotificationsLoaded } = getExtrasForClient(client);
  use(waitUntilInboxNotificationsLoaded());
  const result = useUnreadInboxNotificationsCount_withClient(client);
  _core.assert.call(void 0, !result.isLoading, "Did not expect loading");
  _core.assert.call(void 0, !result.error, "Did not expect error");
  return result;
}
function useMarkInboxNotificationAsRead_withClient(client) {
  return _react.useCallback.call(void 0, 
    (inboxNotificationId) => {
      const { store } = getExtrasForClient(client);
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const readAt = /* @__PURE__ */ new Date();
      store.pushOptimisticUpdate({
        type: "mark-inbox-notification-as-read",
        id: optimisticUpdateId,
        inboxNotificationId,
        readAt
      });
      client.markInboxNotificationAsRead(inboxNotificationId).then(
        () => {
          store.set((state) => {
            const existingNotification = state.inboxNotifications[inboxNotificationId];
            if (existingNotification === void 0) {
              return {
                ...state,
                optimisticUpdates: state.optimisticUpdates.filter(
                  (update) => update.id !== optimisticUpdateId
                )
              };
            }
            return {
              ...state,
              inboxNotifications: {
                ...state.inboxNotifications,
                [inboxNotificationId]: {
                  ...existingNotification,
                  readAt
                }
              },
              optimisticUpdates: state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              )
            };
          });
        },
        () => {
          store.set((state) => ({
            ...state,
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        }
      );
    },
    [client]
  );
}
function useMarkAllInboxNotificationsAsRead_withClient(client) {
  return _react.useCallback.call(void 0, () => {
    const { store } = getExtrasForClient(client);
    const optimisticUpdateId = _core.nanoid.call(void 0, );
    const readAt = /* @__PURE__ */ new Date();
    store.pushOptimisticUpdate({
      type: "mark-all-inbox-notifications-as-read",
      id: optimisticUpdateId,
      readAt
    });
    client.markAllInboxNotificationsAsRead().then(
      () => {
        store.set((state) => ({
          ...state,
          inboxNotifications: Object.fromEntries(
            Array.from(Object.entries(state.inboxNotifications)).map(
              ([id, inboxNotification]) => [
                id,
                { ...inboxNotification, readAt }
              ]
            )
          ),
          optimisticUpdates: state.optimisticUpdates.filter(
            (update) => update.id !== optimisticUpdateId
          )
        }));
      },
      () => {
        store.set((state) => ({
          ...state,
          optimisticUpdates: state.optimisticUpdates.filter(
            (update) => update.id !== optimisticUpdateId
          )
        }));
      }
    );
  }, [client]);
}
function useDeleteInboxNotification_withClient(client) {
  return _react.useCallback.call(void 0, 
    (inboxNotificationId) => {
      const { store } = getExtrasForClient(client);
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const deletedAt = /* @__PURE__ */ new Date();
      store.pushOptimisticUpdate({
        type: "delete-inbox-notification",
        id: optimisticUpdateId,
        inboxNotificationId,
        deletedAt
      });
      client.deleteInboxNotification(inboxNotificationId).then(
        () => {
          store.set((state) => {
            const existingNotification = state.inboxNotifications[inboxNotificationId];
            if (existingNotification === void 0) {
              return {
                ...state,
                optimisticUpdates: state.optimisticUpdates.filter(
                  (update) => update.id !== optimisticUpdateId
                )
              };
            }
            const { [inboxNotificationId]: _, ...inboxNotifications } = state.inboxNotifications;
            return {
              ...state,
              inboxNotifications,
              optimisticUpdates: state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              )
            };
          });
        },
        () => {
          store.set((state) => ({
            ...state,
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        }
      );
    },
    [client]
  );
}
function useDeleteAllInboxNotifications_withClient(client) {
  return _react.useCallback.call(void 0, () => {
    const { store } = getExtrasForClient(client);
    const optimisticUpdateId = _core.nanoid.call(void 0, );
    const deletedAt = /* @__PURE__ */ new Date();
    store.pushOptimisticUpdate({
      type: "delete-all-inbox-notifications",
      id: optimisticUpdateId,
      deletedAt
    });
    client.deleteAllInboxNotifications().then(
      () => {
        store.set((state) => ({
          ...state,
          inboxNotifications: {},
          optimisticUpdates: state.optimisticUpdates.filter(
            (update) => update.id !== optimisticUpdateId
          )
        }));
      },
      () => {
        store.set((state) => ({
          ...state,
          optimisticUpdates: state.optimisticUpdates.filter(
            (update) => update.id !== optimisticUpdateId
          )
        }));
      }
    );
  }, [client]);
}
function useInboxNotificationThread_withClient(client, inboxNotificationId) {
  const { store } = getExtrasForClient(client);
  const selector = _react.useCallback.call(void 0, 
    (state) => {
      const inboxNotification = _nullishCoalesce(state.inboxNotifications[inboxNotificationId], () => ( _core.raise.call(void 0, `Inbox notification with ID "${inboxNotificationId}" not found`)));
      if (inboxNotification.kind !== "thread") {
        _core.raise.call(void 0, 
          `Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`
        );
      }
      const thread = _nullishCoalesce(state.threads[inboxNotification.threadId], () => ( _core.raise.call(void 0, 
        `Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`
      )));
      return thread;
    },
    [inboxNotificationId]
  );
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selector
  );
}
function useUser_withClient(client, userId) {
  const usersStore = client[_core.kInternal].usersStore;
  const getUserState = _react.useCallback.call(void 0, 
    () => usersStore.getState(userId),
    [usersStore, userId]
  );
  _react.useEffect.call(void 0, () => {
    void usersStore.get(userId);
  }, [usersStore, userId]);
  const selector = _react.useCallback.call(void 0, 
    (state) => selectorFor_useUser(state, userId),
    [userId]
  );
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    usersStore.subscribe,
    getUserState,
    getUserState,
    selector,
    _core.shallow
  );
}
function useUserSuspense_withClient(client, userId) {
  const usersStore = client[_core.kInternal].usersStore;
  const getUserState = _react.useCallback.call(void 0, 
    () => usersStore.getState(userId),
    [usersStore, userId]
  );
  const userState = getUserState();
  if (!userState || userState.isLoading) {
    throw usersStore.get(userId);
  }
  if (userState.error) {
    throw userState.error;
  }
  if (!userState.data) {
    throw missingUserError(userId);
  }
  const state = _indexjs.useSyncExternalStore.call(void 0, 
    usersStore.subscribe,
    getUserState,
    getUserState
  );
  _core.assert.call(void 0, state !== void 0, "Unexpected missing state");
  _core.assert.call(void 0, !state.isLoading, "Unexpected loading state");
  _core.assert.call(void 0, !state.error, "Unexpected error state");
  return {
    isLoading: false,
    user: state.data,
    error: void 0
  };
}
function useRoomInfo_withClient(client, roomId) {
  const roomsInfoStore = client[_core.kInternal].roomsInfoStore;
  const getRoomInfoState = _react.useCallback.call(void 0, 
    () => roomsInfoStore.getState(roomId),
    [roomsInfoStore, roomId]
  );
  const selector = _react.useCallback.call(void 0, 
    (state) => selectorFor_useRoomInfo(state, roomId),
    [roomId]
  );
  _react.useEffect.call(void 0, () => {
    void roomsInfoStore.get(roomId);
  }, [roomsInfoStore, roomId]);
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState,
    selector,
    _core.shallow
  );
}
function useRoomInfoSuspense_withClient(client, roomId) {
  const roomsInfoStore = client[_core.kInternal].roomsInfoStore;
  const getRoomInfoState = _react.useCallback.call(void 0, 
    () => roomsInfoStore.getState(roomId),
    [roomsInfoStore, roomId]
  );
  const roomInfoState = getRoomInfoState();
  if (!roomInfoState || roomInfoState.isLoading) {
    throw roomsInfoStore.get(roomId);
  }
  if (roomInfoState.error) {
    throw roomInfoState.error;
  }
  if (!roomInfoState.data) {
    throw missingRoomInfoError(roomId);
  }
  const state = _indexjs.useSyncExternalStore.call(void 0, 
    roomsInfoStore.subscribe,
    getRoomInfoState,
    getRoomInfoState
  );
  _core.assert.call(void 0, state !== void 0, "Unexpected missing state");
  _core.assert.call(void 0, !state.isLoading, "Unexpected loading state");
  _core.assert.call(void 0, !state.error, "Unexpected error state");
  _core.assert.call(void 0, state.data !== void 0, "Unexpected missing room info data");
  return {
    isLoading: false,
    info: state.data,
    error: void 0
  };
}
function createSharedContext(client) {
  const useClient2 = () => client;
  return {
    classic: {
      useClient: useClient2,
      useUser: (userId) => useUser_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),
      useIsInsideRoom: _useIsInsideRoom
    },
    suspense: {
      useClient: useClient2,
      useUser: (userId) => useUserSuspense_withClient(client, userId),
      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),
      useIsInsideRoom: _useIsInsideRoom
    }
  };
}
function useEnsureNoLiveblocksProvider(options) {
  const existing = useClientOrNull();
  if (!_optionalChain([options, 'optionalAccess', _4 => _4.allowNesting]) && existing !== null) {
    throw new Error(
      "You cannot nest multiple LiveblocksProvider instances in the same React tree."
    );
  }
}
function useClientOrNull() {
  return _react.useContext.call(void 0, ClientContext);
}
function useClient() {
  return _nullishCoalesce(useClientOrNull(), () => ( _core.raise.call(void 0, "LiveblocksProvider is missing from the React tree.")));
}
function LiveblocksProviderWithClient(props) {
  useEnsureNoLiveblocksProvider(props);
  return /* @__PURE__ */ React.default.createElement(ClientContext.Provider, { value: props.client }, props.children);
}
function LiveblocksProvider(props) {
  const { children, ...o } = props;
  const options = {
    publicApiKey: useInitial(o.publicApiKey),
    throttle: useInitial(o.throttle),
    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),
    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),
    polyfills: useInitial(o.polyfills),
    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),
    unstable_streamData: useInitial(o.unstable_streamData),
    authEndpoint: useInitialUnlessFunction(o.authEndpoint),
    resolveMentionSuggestions: useInitialUnlessFunction(
      o.resolveMentionSuggestions
    ),
    resolveUsers: useInitialUnlessFunction(o.resolveUsers),
    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),
    baseUrl: useInitial(
      // @ts-expect-error - Hidden config options
      o.baseUrl
    ),
    enableDebugLogging: useInitial(
      // @ts-expect-error - Hidden config options
      o.enableDebugLogging
    )
  };
  const client = _react.useMemo.call(void 0, () => _core.createClient.call(void 0, options), []);
  return /* @__PURE__ */ React.default.createElement(LiveblocksProviderWithClient, { client }, children);
}
function createLiveblocksContext(client) {
  return getOrCreateContextBundle(client);
}
function useUserThreads_experimental() {
  return useUserThreads_withClient(useClient());
}
function useUserThreadsSuspense_experimental() {
  return useUserThreadsSuspense_withClient(useClient());
}
function useInboxNotifications() {
  return useInboxNotifications_withClient(useClient());
}
function useInboxNotificationsSuspense() {
  return useInboxNotificationsSuspense_withClient(useClient());
}
function useInboxNotificationThread(inboxNotificationId) {
  return useInboxNotificationThread_withClient(
    useClient(),
    inboxNotificationId
  );
}
function useMarkAllInboxNotificationsAsRead() {
  return useMarkAllInboxNotificationsAsRead_withClient(useClient());
}
function useMarkInboxNotificationAsRead() {
  return useMarkInboxNotificationAsRead_withClient(useClient());
}
function useDeleteAllInboxNotifications() {
  return useDeleteAllInboxNotifications_withClient(useClient());
}
function useDeleteInboxNotification() {
  return useDeleteInboxNotification_withClient(useClient());
}
function useUnreadInboxNotificationsCount() {
  return useUnreadInboxNotificationsCount_withClient(useClient());
}
function useUnreadInboxNotificationsCountSuspense() {
  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());
}
function useUser(userId) {
  const client = useClient();
  return useUser_withClient(client, userId);
}
function useUserSuspense(userId) {
  const client = useClient();
  return useUserSuspense_withClient(client, userId);
}
function useRoomInfo(roomId) {
  return useRoomInfo_withClient(useClient(), roomId);
}
function useRoomInfoSuspense(roomId) {
  return useRoomInfoSuspense_withClient(useClient(), roomId);
}
var _useInboxNotificationThread = useInboxNotificationThread;
var _useUser = useUser;
var _useUserSuspense = useUserSuspense;
var _useUserThreads_experimental = useUserThreads_experimental;
var _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;

// src/use-scroll-to-comment-on-load-effect.ts

function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
  if (shouldScrollOnLoad === false) return;
  if (state.isLoading) return;
  const isWindowDefined = typeof window !== "undefined";
  if (!isWindowDefined) return;
  const hash = window.location.hash;
  const commentId = hash.slice(1);
  if (!commentId.startsWith("cm_")) return;
  const comment = document.getElementById(commentId);
  if (comment === null) return;
  const comments = state.threads.flatMap((thread) => thread.comments);
  const isCommentInThreads = comments.some(
    (comment2) => comment2.id === commentId
  );
  if (!isCommentInThreads) return;
  comment.scrollIntoView();
}
function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
  React3.useEffect(
    () => {
      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once
    [state.isLoading]
  );
}

// src/room.tsx
var SMOOTH_DELAY = 1e3;
var noop2 = () => {
};
var identity = (x) => x;
var missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\u2019re ready to upgrade to React 18:

    import { unstable_batchedUpdates } from "react-dom";  // or "react-native"

    <RoomProvider id=${JSON.stringify(
  roomId
)} ... unstable_batchedUpdates={unstable_batchedUpdates}>
      ...
    </RoomProvider>

Why? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`;
var superfluous_unstable_batchedUpdates = "You don\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\u2019re on React 18+ already.";
function useSyncExternalStore2(s, gs, gss) {
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, s, gs, gss, identity);
}
var STABLE_EMPTY_LIST = Object.freeze([]);
var POLLING_INTERVAL2 = 5 * 60 * 1e3;
function makeNotificationSettingsQueryKey(roomId) {
  return `${roomId}:NOTIFICATION_SETTINGS`;
}
function alwaysEmptyList() {
  return STABLE_EMPTY_LIST;
}
function alwaysNull() {
  return null;
}
function selectorFor_useOthersConnectionIds(others) {
  return others.map((user) => user.connectionId);
}
function makeMutationContext(room) {
  const cannotUseUntil = "This mutation cannot be used until";
  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;
  const needsStorage = `${cannotUseUntil} storage has been loaded`;
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(needsStorage);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(needsPresence);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(needsPresence);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
function getCurrentUserId(room) {
  const self = room.getSelf();
  if (self === null || self.id === void 0) {
    return "anonymous";
  } else {
    return self.id;
  }
}
function handleApiError(err) {
  const message = `Request failed with status ${err.status}: ${err.message}`;
  if (_optionalChain([err, 'access', _5 => _5.details, 'optionalAccess', _6 => _6.error]) === "FORBIDDEN") {
    const detailedMessage = [message, err.details.suggestion, err.details.docs].filter(Boolean).join("\n");
    _core.console.error(detailedMessage);
  }
  return new Error(message);
}
var _extras2 = /* @__PURE__ */ new WeakMap();
var _bundles2 = /* @__PURE__ */ new WeakMap();
function getOrCreateRoomContextBundle(client) {
  let bundle = _bundles2.get(client);
  if (!bundle) {
    bundle = makeRoomContextBundle(client);
    _bundles2.set(client, bundle);
  }
  return bundle;
}
function getExtrasForClient2(client) {
  let extras = _extras2.get(client);
  if (!extras) {
    extras = makeExtrasForClient2(client);
    _extras2.set(client, extras);
  }
  return extras;
}
function makeExtrasForClient2(client) {
  const store = client[_core.kInternal].cacheStore;
  const DEFAULT_DEDUPING_INTERVAL = 2e3;
  const lastRequestedAtByRoom = /* @__PURE__ */ new Map();
  const requestsByQuery = /* @__PURE__ */ new Map();
  const requestStatusByRoom = /* @__PURE__ */ new Map();
  const subscribersByQuery = /* @__PURE__ */ new Map();
  const poller = _core.makePoller.call(void 0, refreshThreadsAndNotifications);
  async function refreshThreadsAndNotifications() {
    const requests = [];
    client[_core.kInternal].getRoomIds().map((roomId) => {
      const room = client.getRoom(roomId);
      if (room === null) return;
      requests.push(getThreadsUpdates(room.id));
    });
    await Promise.allSettled(requests);
  }
  function incrementQuerySubscribers(queryKey) {
    const subscribers = _nullishCoalesce(subscribersByQuery.get(queryKey), () => ( 0));
    subscribersByQuery.set(queryKey, subscribers + 1);
    poller.start(POLLING_INTERVAL2);
    return () => {
      const subscribers2 = subscribersByQuery.get(queryKey);
      if (subscribers2 === void 0 || subscribers2 <= 0) {
        _core.console.warn(
          `Internal unexpected behavior. Cannot decrease subscriber count for query "${queryKey}"`
        );
        return;
      }
      subscribersByQuery.set(queryKey, subscribers2 - 1);
      let totalSubscribers = 0;
      for (const subscribers3 of subscribersByQuery.values()) {
        totalSubscribers += subscribers3;
      }
      if (totalSubscribers <= 0) {
        poller.stop();
      }
    };
  }
  async function getThreadsUpdates(roomId) {
    const room = client.getRoom(roomId);
    if (room === null) return;
    const since = lastRequestedAtByRoom.get(room.id);
    if (since === void 0) return;
    const isFetchingThreadsUpdates = _nullishCoalesce(requestStatusByRoom.get(room.id), () => ( false));
    if (isFetchingThreadsUpdates === true) return;
    try {
      requestStatusByRoom.set(room.id, true);
      const updates = await room.getThreadsSince({ since });
      setTimeout(() => {
        requestStatusByRoom.set(room.id, false);
      }, DEFAULT_DEDUPING_INTERVAL);
      store.updateThreadsAndNotifications(
        updates.threads.updated,
        updates.inboxNotifications.updated,
        updates.threads.deleted,
        updates.inboxNotifications.deleted
      );
      lastRequestedAtByRoom.set(room.id, updates.requestedAt);
    } catch (err) {
      requestStatusByRoom.set(room.id, false);
      return;
    }
  }
  async function getThreadsAndInboxNotifications(room, queryKey, options, { retryCount } = { retryCount: 0 }) {
    const existingRequest = requestsByQuery.get(queryKey);
    if (existingRequest !== void 0) return existingRequest;
    const request = room.getThreads(options);
    requestsByQuery.set(queryKey, request);
    store.setQueryState(queryKey, {
      isLoading: true
    });
    try {
      const result = await request;
      store.updateThreadsAndNotifications(
        result.threads,
        // TODO: Figure out how to remove this casting
        result.inboxNotifications,
        [],
        [],
        queryKey
      );
      const lastRequestedAt = lastRequestedAtByRoom.get(room.id);
      if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {
        lastRequestedAtByRoom.set(room.id, result.requestedAt);
      }
      poller.start(POLLING_INTERVAL2);
    } catch (err) {
      requestsByQuery.delete(queryKey);
      retryError(() => {
        void getThreadsAndInboxNotifications(room, queryKey, options, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryState(queryKey, {
        isLoading: false,
        error: err
      });
    }
    return;
  }
  async function getInboxNotificationSettings(room, queryKey, { retryCount } = { retryCount: 0 }) {
    const existingRequest = requestsByQuery.get(queryKey);
    if (existingRequest !== void 0) return existingRequest;
    try {
      const request = room.getNotificationSettings();
      requestsByQuery.set(queryKey, request);
      store.setQueryState(queryKey, {
        isLoading: true
      });
      const settings = await request;
      store.updateRoomInboxNotificationSettings(room.id, settings, queryKey);
    } catch (err) {
      requestsByQuery.delete(queryKey);
      retryError(() => {
        void getInboxNotificationSettings(room, queryKey, {
          retryCount: retryCount + 1
        });
      }, retryCount);
      store.setQueryState(queryKey, {
        isLoading: false,
        error: err
      });
    }
    return;
  }
  const commentsErrorEventSource = _core.makeEventSource.call(void 0, );
  function onMutationFailure(innerError, optimisticUpdateId, createPublicError) {
    store.set((state) => ({
      ...state,
      optimisticUpdates: state.optimisticUpdates.filter(
        (update) => update.id !== optimisticUpdateId
      )
    }));
    if (innerError instanceof _core.CommentsApiError) {
      const error = handleApiError(innerError);
      commentsErrorEventSource.notify(createPublicError(error));
      return;
    }
    if (innerError instanceof _core.NotificationsApiError) {
      handleApiError(innerError);
      return;
    }
    throw innerError;
  }
  return {
    store,
    incrementQuerySubscribers,
    commentsErrorEventSource,
    getThreadsUpdates,
    getThreadsAndInboxNotifications,
    getInboxNotificationSettings,
    onMutationFailure
  };
}
var RoomContext = React4.createContext(null);
function makeRoomContextBundle(client) {
  function RoomProvider_withImplicitLiveblocksProvider(props) {
    return /* @__PURE__ */ React4.createElement(LiveblocksProviderWithClient, { client, allowNesting: true }, /* @__PURE__ */ React4.createElement(RoomProvider, { ...props }));
  }
  const shared = createSharedContext(client);
  const bundle = {
    RoomContext,
    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
    useRoom,
    useStatus,
    useStorageStatus,
    useBatch,
    useBroadcastEvent,
    useOthersListener,
    useLostConnectionListener,
    useErrorListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useCreateThread,
    useDeleteThread,
    useEditThreadMetadata,
    useMarkThreadAsResolved,
    useMarkThreadAsUnresolved,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    useMarkThreadAsRead,
    useThreadSubscription,
    useRoomNotificationSettings,
    useUpdateRoomNotificationSettings,
    ...shared.classic,
    suspense: {
      RoomContext,
      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,
      useRoom,
      useStatus,
      useStorageStatus: useStorageStatusSuspense,
      useBatch,
      useBroadcastEvent,
      useOthersListener,
      useLostConnectionListener,
      useErrorListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useCreateThread,
      useDeleteThread,
      useEditThreadMetadata,
      useMarkThreadAsResolved,
      useMarkThreadAsUnresolved,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction,
      useMarkThreadAsRead,
      useThreadSubscription,
      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,
      useUpdateRoomNotificationSettings,
      ...shared.suspense
    },
    useCommentsErrorListener
  };
  return Object.defineProperty(bundle, _core.kInternal, {
    enumerable: false
  });
}
function RoomProvider(props) {
  const client = useClient();
  const [cache] = React4.useState(
    () => /* @__PURE__ */ new Map()
  );
  const stableEnterRoom = React4.useCallback(
    (roomId, options) => {
      const cached = cache.get(roomId);
      if (cached) return cached;
      const rv = client.enterRoom(roomId, options);
      const origLeave = rv.leave;
      rv.leave = () => {
        origLeave();
        cache.delete(roomId);
      };
      cache.set(roomId, rv);
      return rv;
    },
    [client, cache]
  );
  return /* @__PURE__ */ React4.createElement(
    RoomProviderInner,
    {
      ...props,
      stableEnterRoom
    }
  );
}
function RoomProviderInner(props) {
  const client = useClient();
  const { id: roomId, stableEnterRoom } = props;
  if (process.env.NODE_ENV !== "production") {
    if (!roomId) {
      throw new Error(
        "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
      );
    }
    if (typeof roomId !== "string") {
      throw new Error("RoomProvider id property should be a string.");
    }
    const majorReactVersion = parseInt(React4.version) || 1;
    const oldReactVersion = majorReactVersion < 18;
    _core.errorIf.call(void 0, 
      oldReactVersion && props.unstable_batchedUpdates === void 0,
      missing_unstable_batchedUpdates(majorReactVersion, roomId)
    );
    _core.deprecateIf.call(void 0, 
      !oldReactVersion && props.unstable_batchedUpdates !== void 0,
      superfluous_unstable_batchedUpdates
    );
  }
  const frozenProps = useInitial({
    initialPresence: props.initialPresence,
    initialStorage: props.initialStorage,
    unstable_batchedUpdates: props.unstable_batchedUpdates,
    autoConnect: _nullishCoalesce(props.autoConnect, () => ( typeof window !== "undefined"))
  });
  const [{ room }, setRoomLeavePair] = React4.useState(
    () => stableEnterRoom(roomId, {
      ...frozenProps,
      autoConnect: false
      // Deliberately using false here on the first render, see below
    })
  );
  React4.useEffect(() => {
    const { store } = getExtrasForClient2(client);
    async function handleCommentEvent(message) {
      if (message.type === _core.ServerMsgCode.THREAD_DELETED) {
        store.deleteThread(message.threadId);
        return;
      }
      const info = await room.getThread(message.threadId);
      if (!info.thread) {
        store.deleteThread(message.threadId);
        return;
      }
      const { thread, inboxNotification } = info;
      const existingThread = store.get().threads[message.threadId];
      switch (message.type) {
        case _core.ServerMsgCode.COMMENT_EDITED:
        case _core.ServerMsgCode.THREAD_METADATA_UPDATED:
        case _core.ServerMsgCode.THREAD_UPDATED:
        case _core.ServerMsgCode.COMMENT_REACTION_ADDED:
        case _core.ServerMsgCode.COMMENT_REACTION_REMOVED:
        case _core.ServerMsgCode.COMMENT_DELETED:
          if (!existingThread) break;
          store.updateThreadAndNotification(thread, inboxNotification);
          break;
        case _core.ServerMsgCode.COMMENT_CREATED:
          store.updateThreadAndNotification(thread, inboxNotification);
          break;
        default:
          break;
      }
    }
    return room.events.comments.subscribe(
      (message) => void handleCommentEvent(message)
    );
  }, [client, room]);
  React4.useEffect(() => {
    const { getThreadsUpdates } = getExtrasForClient2(client);
    void getThreadsUpdates(room.id);
  }, [client, room.id]);
  React4.useEffect(() => {
    function handleIsOnline() {
      const { getThreadsUpdates } = getExtrasForClient2(client);
      void getThreadsUpdates(room.id);
    }
    window.addEventListener("online", handleIsOnline);
    return () => {
      window.removeEventListener("online", handleIsOnline);
    };
  }, [client, room.id]);
  React4.useEffect(() => {
    const pair = stableEnterRoom(roomId, frozenProps);
    setRoomLeavePair(pair);
    const { room: room2, leave } = pair;
    if (frozenProps.autoConnect) {
      room2.connect();
    }
    return () => {
      leave();
    };
  }, [roomId, frozenProps, stableEnterRoom]);
  return /* @__PURE__ */ React4.createElement(RoomContext.Provider, { value: room }, props.children);
}
function useRoom() {
  const room = useRoomOrNull();
  if (room === null) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return room;
}
function useIsInsideRoom() {
  const room = useRoomOrNull();
  return room !== null;
}
function useStatus() {
  const room = useRoom();
  const subscribe = room.events.status.subscribe;
  const getSnapshot = room.getStatus;
  const getServerSnapshot = room.getStatus;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatus(options) {
  const smooth = useInitial(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _7 => _7.smooth]), () => ( false)));
  if (smooth) {
    return useStorageStatusSmooth();
  } else {
    return useStorageStatusImmediate();
  }
}
function useStorageStatusImmediate() {
  const room = useRoom();
  const subscribe = room.events.storageStatus.subscribe;
  const getSnapshot = room.getStorageStatus;
  const getServerSnapshot = room.getStorageStatus;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageStatusSmooth() {
  const room = useRoom();
  const [status, setStatus] = React4.useState(room.getStorageStatus);
  const oldStatus = useLatest(room.getStorageStatus());
  React4.useEffect(() => {
    let timeoutId;
    const unsub = room.events.storageStatus.subscribe((newStatus) => {
      if (oldStatus.current === "synchronizing" && newStatus === "synchronized") {
        timeoutId = setTimeout(() => setStatus(newStatus), SMOOTH_DELAY);
      } else {
        clearTimeout(timeoutId);
        setStatus(newStatus);
      }
    });
    return () => {
      clearTimeout(timeoutId);
      unsub();
    };
  }, [room, oldStatus]);
  return status;
}
function useBatch() {
  return useRoom().batch;
}
function useBroadcastEvent() {
  const room = useRoom();
  return React4.useCallback(
    (event, options = { shouldQueueEventIfNotReady: false }) => {
      room.broadcastEvent(event, options);
    },
    [room]
  );
}
function useOthersListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(
    () => room.events.others.subscribe((event) => savedCallback.current(event)),
    [room, savedCallback]
  );
}
function useLostConnectionListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(
    () => room.events.lostConnection.subscribe(
      (event) => savedCallback.current(event)
    ),
    [room, savedCallback]
  );
}
function useErrorListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(
    () => room.events.error.subscribe((e) => savedCallback.current(e)),
    [room, savedCallback]
  );
}
function useEventListener(callback) {
  const room = useRoom();
  const savedCallback = useLatest(callback);
  React4.useEffect(() => {
    const listener = (eventData) => {
      savedCallback.current(eventData);
    };
    return room.events.customEvent.subscribe(listener);
  }, [room, savedCallback]);
}
function useHistory() {
  return useRoom().history;
}
function useUndo() {
  return useHistory().undo;
}
function useRedo() {
  return useHistory().redo;
}
function useCanUndo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canUndo = room.history.canUndo;
  return useSyncExternalStore2(subscribe, canUndo, canUndo);
}
function useCanRedo() {
  const room = useRoom();
  const subscribe = room.events.history.subscribe;
  const canRedo = room.history.canRedo;
  return useSyncExternalStore2(subscribe, canRedo, canRedo);
}
function useSelf(maybeSelector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.self.subscribe;
  const getSnapshot = room.getSelf;
  const selector = _nullishCoalesce(maybeSelector, () => ( identity));
  const wrappedSelector = React4.useCallback(
    (me) => me !== null ? selector(me) : null,
    [selector]
  );
  const getServerSnapshot = alwaysNull;
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMyPresence() {
  const room = useRoom();
  const subscribe = room.events.myPresence.subscribe;
  const getSnapshot = room.getPresence;
  const presence = useSyncExternalStore2(subscribe, getSnapshot, getSnapshot);
  const setPresence = room.updatePresence;
  return [presence, setPresence];
}
function useUpdateMyPresence() {
  return useRoom().updatePresence;
}
function useOthers(selector, isEqual) {
  const room = useRoom();
  const subscribe = room.events.others.subscribe;
  const getSnapshot = room.getOthers;
  const getServerSnapshot = alwaysEmptyList;
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    subscribe,
    getSnapshot,
    getServerSnapshot,
    _nullishCoalesce(selector, () => ( identity)),
    isEqual
  );
}
function useOthersMapped(itemSelector, itemIsEqual) {
  const wrappedSelector = React4.useCallback(
    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),
    [itemSelector]
  );
  const wrappedIsEqual = React4.useCallback(
    (a, b) => {
      const eq = _nullishCoalesce(itemIsEqual, () => ( Object.is));
      return a.length === b.length && a.every((atuple, index) => {
        const btuple = b[index];
        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
      });
    },
    [itemIsEqual]
  );
  return useOthers(wrappedSelector, wrappedIsEqual);
}
function useOthersConnectionIds() {
  return useOthers(selectorFor_useOthersConnectionIds, _client.shallow);
}
var NOT_FOUND = Symbol();
function useOther(connectionId, selector, isEqual) {
  const wrappedSelector = React4.useCallback(
    (others) => {
      const other2 = others.find((other3) => other3.connectionId === connectionId);
      return other2 !== void 0 ? selector(other2) : NOT_FOUND;
    },
    [connectionId, selector]
  );
  const wrappedIsEqual = React4.useCallback(
    (prev, curr) => {
      if (prev === NOT_FOUND || curr === NOT_FOUND) {
        return prev === curr;
      }
      const eq = _nullishCoalesce(isEqual, () => ( Object.is));
      return eq(prev, curr);
    },
    [isEqual]
  );
  const other = useOthers(wrappedSelector, wrappedIsEqual);
  if (other === NOT_FOUND) {
    throw new Error(
      `No such other user with connection id ${connectionId} exists`
    );
  }
  return other;
}
function useMutableStorageRoot() {
  const room = useRoom();
  const subscribe = room.events.storageDidLoad.subscribeOnce;
  const getSnapshot = room.getStorageSnapshot;
  const getServerSnapshot = alwaysNull;
  return useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot);
}
function useStorageRoot() {
  return [useMutableStorageRoot()];
}
function useStorage(selector, isEqual) {
  const room = useRoom();
  const rootOrNull = useMutableStorageRoot();
  const wrappedSelector = React4.useCallback(
    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
    [selector]
  );
  const subscribe = React4.useCallback(
    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,
    [room, rootOrNull]
  );
  const getSnapshot = React4.useCallback(() => {
    if (rootOrNull === null) {
      return null;
    } else {
      const root = rootOrNull;
      const imm = root.toImmutable();
      return imm;
    }
  }, [rootOrNull]);
  const getServerSnapshot = alwaysNull;
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    subscribe,
    getSnapshot,
    getServerSnapshot,
    wrappedSelector,
    isEqual
  );
}
function useMutation(callback, deps) {
  const room = useRoom();
  return React4.useMemo(
    () => {
      return (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        room.batch(
          () => (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            callback(
              makeMutationContext(room),
              ...args
            )
          )
        )
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [room, ...deps]
  );
}
function useThreads(options = {
  query: { metadata: {} }
}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const queryKey = React4.useMemo(
    () => generateQueryKey(room.id, options.query),
    [room, options]
  );
  const { store, getThreadsAndInboxNotifications, incrementQuerySubscribers } = getExtrasForClient2(client);
  React4.useEffect(() => {
    void getThreadsAndInboxNotifications(room, queryKey, options);
    return incrementQuerySubscribers(queryKey);
  }, [room, queryKey]);
  const selector = React4.useCallback(
    (state2) => {
      const query = state2.queries[queryKey];
      if (query === void 0 || query.isLoading) {
        return {
          isLoading: true
        };
      }
      return {
        threads: selectedThreads(room.id, state2, options),
        isLoading: false,
        error: query.error
      };
    },
    [room, queryKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const state = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selector
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, state);
  return state;
}
function useCommentsErrorListener(callback) {
  const client = useClient();
  const savedCallback = useLatest(callback);
  const { commentsErrorEventSource } = getExtrasForClient2(client);
  React4.useEffect(() => {
    return commentsErrorEventSource.subscribe(savedCallback.current);
  }, [savedCallback, commentsErrorEventSource]);
}
function useCreateThread() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (options) => {
      const body = options.body;
      const metadata = _nullishCoalesce(options.metadata, () => ( {}));
      const threadId = _core.createThreadId.call(void 0, );
      const commentId = _core.createCommentId.call(void 0, );
      const createdAt = /* @__PURE__ */ new Date();
      const newComment = {
        id: commentId,
        threadId,
        roomId: room.id,
        createdAt,
        type: "comment",
        userId: getCurrentUserId(room),
        body,
        reactions: []
      };
      const newThread = {
        id: threadId,
        type: "thread",
        createdAt,
        updatedAt: createdAt,
        roomId: room.id,
        metadata,
        comments: [newComment],
        resolved: false
      };
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "create-thread",
        thread: newThread,
        id: optimisticUpdateId,
        roomId: room.id
      });
      room.createThread({ threadId, commentId, body, metadata }).then(
        (thread) => {
          store.set((state) => ({
            ...state,
            threads: {
              ...state.threads,
              [threadId]: thread
            },
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new CreateThreadError(err2, {
            roomId: room.id,
            threadId,
            commentId,
            body,
            metadata
          })
        )
      );
      return newThread;
    },
    [client, room]
  );
}
function useDeleteThread() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const thread = store.get().threads[threadId];
      const userId = getCurrentUserId(room);
      if (_optionalChain([thread, 'optionalAccess', _8 => _8.comments, 'optionalAccess', _9 => _9[0], 'optionalAccess', _10 => _10.userId]) !== userId) {
        throw new Error("Only the thread creator can delete the thread");
      }
      store.pushOptimisticUpdate({
        type: "delete-thread",
        id: optimisticUpdateId,
        roomId: room.id,
        threadId,
        deletedAt: /* @__PURE__ */ new Date()
      });
      room.deleteThread(threadId).then(
        () => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            if (existingThread === void 0) {
              return state;
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: {
                  ...existingThread,
                  updatedAt: /* @__PURE__ */ new Date(),
                  deletedAt: /* @__PURE__ */ new Date()
                }
              },
              optimisticUpdates: state.optimisticUpdates.filter(
                (update) => update.id !== optimisticUpdateId
              )
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new DeleteThreadError(err2, { roomId: room.id, threadId })
        )
      );
    },
    [client, room]
  );
}
function useEditThreadMetadata() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (options) => {
      if (!options.metadata) {
        return;
      }
      const threadId = options.threadId;
      const metadata = options.metadata;
      const updatedAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "edit-thread-metadata",
        metadata,
        id: optimisticUpdateId,
        threadId,
        updatedAt
      });
      room.editThreadMetadata({ metadata, threadId }).then(
        (metadata2) => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            if (existingThread.deletedAt !== void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: {
                  ...existingThread,
                  metadata: metadata2
                }
              },
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new EditThreadMetadataError(error, {
            roomId: room.id,
            threadId,
            metadata
          })
        )
      );
    },
    [client, room]
  );
}
function useCreateComment() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, body }) => {
      const commentId = _core.createCommentId.call(void 0, );
      const createdAt = /* @__PURE__ */ new Date();
      const comment = {
        id: commentId,
        threadId,
        roomId: room.id,
        type: "comment",
        createdAt,
        userId: getCurrentUserId(room),
        body,
        reactions: []
      };
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "create-comment",
        comment,
        id: optimisticUpdateId
      });
      room.createComment({ threadId, commentId, body }).then(
        (newComment) => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            const inboxNotification = Object.values(
              state.inboxNotifications
            ).find(
              (notification) => notification.kind === "thread" && notification.threadId === threadId
            );
            const updatedInboxNotifications = inboxNotification !== void 0 ? {
              ...state.inboxNotifications,
              [inboxNotification.id]: {
                ...inboxNotification,
                notifiedAt: newComment.createdAt,
                readAt: newComment.createdAt
              }
            } : state.inboxNotifications;
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: _core.upsertComment.call(void 0, existingThread, newComment)
                // Upsert the new comment into the thread comments list (if applicable)
              },
              inboxNotifications: updatedInboxNotifications,
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (err2) => new CreateCommentError(err2, {
            roomId: room.id,
            threadId,
            commentId,
            body
          })
        )
      );
      return comment;
    },
    [client, room]
  );
}
function useEditComment() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId, body }) => {
      const editedAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const thread = store.get().threads[threadId];
      if (thread === void 0) {
        _core.console.warn(
          `Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`
        );
        return;
      }
      const comment = thread.comments.find(
        (comment2) => comment2.id === commentId
      );
      if (comment === void 0 || comment.deletedAt !== void 0) {
        _core.console.warn(
          `Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`
        );
        return;
      }
      store.pushOptimisticUpdate({
        type: "edit-comment",
        comment: {
          ...comment,
          editedAt,
          body
        },
        id: optimisticUpdateId
      });
      room.editComment({ threadId, commentId, body }).then(
        (editedComment) => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: _core.upsertComment.call(void 0, existingThread, editedComment)
                // Upsert the edited comment into the thread comments list (if applicable)
              },
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new EditCommentError(error, {
            roomId: room.id,
            threadId,
            commentId,
            body
          })
        )
      );
    },
    [client, room]
  );
}
function useDeleteComment() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId }) => {
      const deletedAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "delete-comment",
        threadId,
        commentId,
        deletedAt,
        id: optimisticUpdateId,
        roomId: room.id
      });
      room.deleteComment({ threadId, commentId }).then(
        () => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: _core.deleteComment.call(void 0, existingThread, commentId, deletedAt)
              },
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new DeleteCommentError(error, {
            roomId: room.id,
            threadId,
            commentId
          })
        )
      );
    },
    [client, room]
  );
}
function useAddReaction() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId, emoji }) => {
      const createdAt = /* @__PURE__ */ new Date();
      const userId = getCurrentUserId(room);
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "add-reaction",
        threadId,
        commentId,
        reaction: {
          emoji,
          userId,
          createdAt
        },
        id: optimisticUpdateId
      });
      room.addReaction({ threadId, commentId, emoji }).then(
        (addedReaction) => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: _core.addReaction.call(void 0, 
                  existingThread,
                  commentId,
                  addedReaction
                )
              },
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new AddReactionError(error, {
            roomId: room.id,
            threadId,
            commentId,
            emoji
          })
        )
      );
    },
    [client, room]
  );
}
function useRemoveReaction() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    ({ threadId, commentId, emoji }) => {
      const userId = getCurrentUserId(room);
      const removedAt = /* @__PURE__ */ new Date();
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "remove-reaction",
        threadId,
        commentId,
        emoji,
        userId,
        removedAt,
        id: optimisticUpdateId
      });
      room.removeReaction({ threadId, commentId, emoji }).then(
        () => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: _core.removeReaction.call(void 0, 
                  existingThread,
                  commentId,
                  emoji,
                  userId,
                  removedAt
                )
              },
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new RemoveReactionError(error, {
            roomId: room.id,
            threadId,
            commentId,
            emoji
          })
        )
      );
    },
    [client, room]
  );
}
function useMarkThreadAsRead() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const { store, onMutationFailure } = getExtrasForClient2(client);
      const inboxNotification = Object.values(
        store.get().inboxNotifications
      ).find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      if (!inboxNotification) return;
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const now = /* @__PURE__ */ new Date();
      store.pushOptimisticUpdate({
        type: "mark-inbox-notification-as-read",
        id: optimisticUpdateId,
        inboxNotificationId: inboxNotification.id,
        readAt: now
      });
      room.markInboxNotificationAsRead(inboxNotification.id).then(
        () => {
          store.set((state) => ({
            ...state,
            inboxNotifications: {
              ...state.inboxNotifications,
              [inboxNotification.id]: {
                ...inboxNotification,
                readAt: now
              }
            },
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        },
        (err) => {
          onMutationFailure(
            err,
            optimisticUpdateId,
            (error) => new MarkInboxNotificationAsReadError(error, {
              inboxNotificationId: inboxNotification.id
            })
          );
          return;
        }
      );
    },
    [client, room]
  );
}
function useMarkThreadAsResolved() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "mark-thread-as-resolved",
        id: optimisticUpdateId,
        threadId,
        updatedAt
      });
      room.markThreadAsResolved(threadId).then(
        () => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            if (existingThread.deletedAt !== void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: {
                  ...existingThread,
                  resolved: true
                }
              },
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new MarkThreadAsResolvedError(error, {
            roomId: room.id,
            threadId
          })
        )
      );
    },
    [client, room]
  );
}
function useMarkThreadAsUnresolved() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (threadId) => {
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const updatedAt = /* @__PURE__ */ new Date();
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        type: "mark-thread-as-unresolved",
        id: optimisticUpdateId,
        threadId,
        updatedAt
      });
      room.markThreadAsUnresolved(threadId).then(
        () => {
          store.set((state) => {
            const existingThread = state.threads[threadId];
            const updatedOptimisticUpdates = state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            );
            if (existingThread === void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            if (existingThread.deletedAt !== void 0) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            if (existingThread.updatedAt && existingThread.updatedAt > updatedAt) {
              return {
                ...state,
                optimisticUpdates: updatedOptimisticUpdates
              };
            }
            return {
              ...state,
              threads: {
                ...state.threads,
                [threadId]: {
                  ...existingThread,
                  resolved: false
                }
              },
              optimisticUpdates: updatedOptimisticUpdates
            };
          });
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new MarkThreadAsUnresolvedError(error, {
            roomId: room.id,
            threadId
          })
        )
      );
    },
    [client, room]
  );
}
function useThreadSubscription(threadId) {
  const client = useClient();
  const { store } = getExtrasForClient2(client);
  const selector = React4.useCallback(
    (state) => {
      const inboxNotification = selectedInboxNotifications(state).find(
        (inboxNotification2) => inboxNotification2.kind === "thread" && inboxNotification2.threadId === threadId
      );
      const thread = state.threads[threadId];
      if (inboxNotification === void 0 || thread === void 0) {
        return {
          status: "not-subscribed"
        };
      }
      return {
        status: "subscribed",
        unreadSince: inboxNotification.readAt
      };
    },
    [threadId]
  );
  return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selector
  );
}
function useRoomNotificationSettings() {
  const client = useClient();
  const room = useRoom();
  const { store } = getExtrasForClient2(client);
  React4.useEffect(() => {
    const { getInboxNotificationSettings } = getExtrasForClient2(client);
    const queryKey = makeNotificationSettingsQueryKey(room.id);
    void getInboxNotificationSettings(room, queryKey);
  }, [client, room]);
  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
  const selector = React4.useCallback(
    (state) => {
      const query = state.queries[makeNotificationSettingsQueryKey(room.id)];
      if (query === void 0 || query.isLoading) {
        return { isLoading: true };
      }
      if (query.error !== void 0) {
        return { isLoading: false, error: query.error };
      }
      return {
        isLoading: false,
        settings: selectNotificationSettings(room.id, state)
      };
    },
    [room]
  );
  const settings = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selector
  );
  return React4.useMemo(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function useUpdateRoomNotificationSettings() {
  const client = useClient();
  const room = useRoom();
  return React4.useCallback(
    (settings) => {
      const optimisticUpdateId = _core.nanoid.call(void 0, );
      const { store, onMutationFailure } = getExtrasForClient2(client);
      store.pushOptimisticUpdate({
        id: optimisticUpdateId,
        type: "update-notification-settings",
        roomId: room.id,
        settings
      });
      room.updateNotificationSettings(settings).then(
        (settings2) => {
          store.set((state) => ({
            ...state,
            notificationSettings: {
              [room.id]: settings2
            },
            optimisticUpdates: state.optimisticUpdates.filter(
              (update) => update.id !== optimisticUpdateId
            )
          }));
        },
        (err) => onMutationFailure(
          err,
          optimisticUpdateId,
          (error) => new UpdateNotificationSettingsError(error, {
            roomId: room.id
          })
        )
      );
    },
    [client, room]
  );
}
function ensureNotServerSide() {
  if (typeof window === "undefined") {
    throw new Error(
      "You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr"
    );
  }
}
function useSuspendUntilPresenceReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilPresenceReady());
}
function useSelfSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useSelf(
    selector,
    isEqual
  );
}
function useOthersSuspense(selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOthers(
    selector,
    isEqual
  );
}
function useOthersConnectionIdsSuspense() {
  useSuspendUntilPresenceReady();
  return useOthersConnectionIds();
}
function useOthersMappedSuspense(itemSelector, itemIsEqual) {
  useSuspendUntilPresenceReady();
  return useOthersMapped(itemSelector, itemIsEqual);
}
function useOtherSuspense(connectionId, selector, isEqual) {
  useSuspendUntilPresenceReady();
  return useOther(connectionId, selector, isEqual);
}
function useSuspendUntilStorageReady() {
  ensureNotServerSide();
  const room = useRoom();
  use(room.waitUntilStorageReady());
}
function useStorageSuspense(selector, isEqual) {
  useSuspendUntilStorageReady();
  return useStorage(
    selector,
    isEqual
  );
}
function useStorageStatusSuspense(options) {
  useSuspendUntilStorageReady();
  return useStorageStatus(options);
}
function useThreadsSuspense(options = {
  query: { metadata: {} }
}) {
  const { scrollOnLoad = true } = options;
  const client = useClient();
  const room = useRoom();
  const queryKey = React4.useMemo(
    () => generateQueryKey(room.id, options.query),
    [room, options]
  );
  const { store, getThreadsAndInboxNotifications } = getExtrasForClient2(client);
  const query = store.get().queries[queryKey];
  if (query === void 0 || query.isLoading) {
    throw getThreadsAndInboxNotifications(room, queryKey, options);
  }
  if (query.error) {
    throw query.error;
  }
  const selector = React4.useCallback(
    (state2) => {
      return {
        threads: selectedThreads(room.id, state2, options),
        isLoading: false
      };
    },
    [room, queryKey]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  React4.useEffect(() => {
    const { incrementQuerySubscribers } = getExtrasForClient2(client);
    return incrementQuerySubscribers(queryKey);
  }, [client, queryKey]);
  const state = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selector
  );
  useScrollToCommentOnLoadEffect(scrollOnLoad, state);
  return state;
}
function useRoomNotificationSettingsSuspense() {
  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
  const client = useClient();
  const room = useRoom();
  const queryKey = makeNotificationSettingsQueryKey(room.id);
  const { store, getInboxNotificationSettings } = getExtrasForClient2(client);
  const query = store.get().queries[queryKey];
  if (query === void 0 || query.isLoading) {
    throw getInboxNotificationSettings(room, queryKey);
  }
  if (query.error) {
    throw query.error;
  }
  const selector = React4.useCallback(
    (state) => {
      return {
        isLoading: false,
        settings: selectNotificationSettings(room.id, state)
      };
    },
    [room]
  );
  const settings = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, 
    store.subscribe,
    store.get,
    store.get,
    selector
  );
  return React4.useMemo(() => {
    return [settings, updateRoomNotificationSettings];
  }, [settings, updateRoomNotificationSettings]);
}
function useRoomOrNull() {
  return React4.useContext(RoomContext);
}
function createRoomContext(client) {
  return getOrCreateRoomContextBundle(client);
}
function generateQueryKey(roomId, options) {
  return `${roomId}-${_core.stringify.call(void 0, _nullishCoalesce(options, () => ( {})))}`;
}
var _RoomProvider = RoomProvider;
var _useBroadcastEvent = useBroadcastEvent;
var _useOthersListener = useOthersListener;
var _useRoom = useRoom;
var _useIsInsideRoom = useIsInsideRoom;
var _useAddReaction = useAddReaction;
var _useMutation = useMutation;
var _useCreateThread = useCreateThread;
var _useDeleteThread = useDeleteThread;
var _useEditThreadMetadata = useEditThreadMetadata;
var _useEventListener = useEventListener;
var _useMyPresence = useMyPresence;
var _useOthersMapped = useOthersMapped;
var _useOthersMappedSuspense = useOthersMappedSuspense;
var _useThreads = useThreads;
var _useThreadsSuspense = useThreadsSuspense;
var _useOther = useOther;
function _useOthers(...args) {
  return useOthers(...args);
}
var _useOtherSuspense = useOtherSuspense;
function _useOthersSuspense(...args) {
  return useOthersSuspense(...args);
}
var _useStorage = useStorage;
var _useStorageSuspense = useStorageSuspense;
function _useSelf(...args) {
  return useSelf(...args);
}
function _useSelfSuspense(...args) {
  return useSelfSuspense(...args);
}
var _useStorageRoot = useStorageRoot;
var _useUpdateMyPresence = useUpdateMyPresence;















































































exports.PKG_NAME = PKG_NAME; exports.PKG_VERSION = PKG_VERSION; exports.PKG_FORMAT = PKG_FORMAT; exports.ClientSideSuspense = ClientSideSuspense; exports.selectedThreads = selectedThreads; exports.CreateThreadError = CreateThreadError; exports.RoomContext = RoomContext; exports.useStatus = useStatus; exports.useStorageStatus = useStorageStatus; exports.useBatch = useBatch; exports.useLostConnectionListener = useLostConnectionListener; exports.useErrorListener = useErrorListener; exports.useHistory = useHistory; exports.useUndo = useUndo; exports.useRedo = useRedo; exports.useCanUndo = useCanUndo; exports.useCanRedo = useCanRedo; exports.useOthersConnectionIds = useOthersConnectionIds; exports.useCommentsErrorListener = useCommentsErrorListener; exports.useCreateComment = useCreateComment; exports.useEditComment = useEditComment; exports.useDeleteComment = useDeleteComment; exports.useRemoveReaction = useRemoveReaction; exports.useMarkThreadAsRead = useMarkThreadAsRead; exports.useMarkThreadAsResolved = useMarkThreadAsResolved; exports.useMarkThreadAsUnresolved = useMarkThreadAsUnresolved; exports.useThreadSubscription = useThreadSubscription; exports.useRoomNotificationSettings = useRoomNotificationSettings; exports.useUpdateRoomNotificationSettings = useUpdateRoomNotificationSettings; exports.useOthersConnectionIdsSuspense = useOthersConnectionIdsSuspense; exports.useStorageStatusSuspense = useStorageStatusSuspense; exports.createRoomContext = createRoomContext; exports._RoomProvider = _RoomProvider; exports._useBroadcastEvent = _useBroadcastEvent; exports._useOthersListener = _useOthersListener; exports._useRoom = _useRoom; exports._useIsInsideRoom = _useIsInsideRoom; exports._useAddReaction = _useAddReaction; exports._useMutation = _useMutation; exports._useCreateThread = _useCreateThread; exports._useDeleteThread = _useDeleteThread; exports._useEditThreadMetadata = _useEditThreadMetadata; exports._useEventListener = _useEventListener; exports._useMyPresence = _useMyPresence; exports._useOthersMapped = _useOthersMapped; exports._useOthersMappedSuspense = _useOthersMappedSuspense; exports._useThreads = _useThreads; exports._useThreadsSuspense = _useThreadsSuspense; exports._useOther = _useOther; exports._useOthers = _useOthers; exports._useOtherSuspense = _useOtherSuspense; exports._useOthersSuspense = _useOthersSuspense; exports._useStorage = _useStorage; exports._useStorageSuspense = _useStorageSuspense; exports._useSelf = _useSelf; exports._useSelfSuspense = _useSelfSuspense; exports._useStorageRoot = _useStorageRoot; exports._useUpdateMyPresence = _useUpdateMyPresence; exports.ClientContext = ClientContext; exports.useClient = useClient; exports.LiveblocksProvider = LiveblocksProvider; exports.createLiveblocksContext = createLiveblocksContext; exports.useInboxNotifications = useInboxNotifications; exports.useInboxNotificationsSuspense = useInboxNotificationsSuspense; exports.useMarkAllInboxNotificationsAsRead = useMarkAllInboxNotificationsAsRead; exports.useMarkInboxNotificationAsRead = useMarkInboxNotificationAsRead; exports.useDeleteAllInboxNotifications = useDeleteAllInboxNotifications; exports.useDeleteInboxNotification = useDeleteInboxNotification; exports.useUnreadInboxNotificationsCount = useUnreadInboxNotificationsCount; exports.useUnreadInboxNotificationsCountSuspense = useUnreadInboxNotificationsCountSuspense; exports.useRoomInfo = useRoomInfo; exports.useRoomInfoSuspense = useRoomInfoSuspense; exports._useInboxNotificationThread = _useInboxNotificationThread; exports._useUser = _useUser; exports._useUserSuspense = _useUserSuspense; exports._useUserThreads_experimental = _useUserThreads_experimental; exports._useUserThreadsSuspense_experimental = _useUserThreadsSuspense_experimental;
//# sourceMappingURL=chunk-WILOQTZP.js.map